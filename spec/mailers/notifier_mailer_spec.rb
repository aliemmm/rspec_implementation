RSpec.describe NotifierMailer do
  describe "task_due_today" do
    let(:team) { create(:team, time_zone: "Pacific Time (US & Canada)") }
    let(:designer) { create(:user, :designer, team:) }
    let(:assignee) { create(:user, :member, team:) }
    let(:project) { create(:project, designers: [designer], created_by: designer, id: 13) }

    it "sends the email when the task is due today, assigned to someone and not completed" do
      task = create(:task, project:, due_date: Time.zone.today, assignee:,
        completed: false, team:)

      expect do
        described_class.task_due_today(task).deliver_now
      end.to change(ActionMailer::Base.deliveries, :count).by(1)
    end

    it "does NOT send the email when the task is not present" do
      task = create(:task, project:, due_date: Time.zone.today, assignee:,
        completed: false, team:)
      # Queueing the email before deleting the task in case the (current or future) background job caches the task
      email = described_class.task_due_today(task)
      task.destroy!

      expect do
        email.deliver_now
      end.not_to change(ActionMailer::Base.deliveries, :count)
    end

    it "does NOT send the email when the task is not due today" do
      task = create(:task, project:, assignee:, completed: false, team:)

      expect do
        described_class.task_due_today(task).deliver_now
      end.not_to change(ActionMailer::Base.deliveries, :count)
    end

    it "does NOT send the email when the task has no assignee" do
      task = create(:task, project:, due_date: Time.zone.today, completed: false, team:)

      expect do
        described_class.task_due_today(task).deliver_now
      end.not_to change(ActionMailer::Base.deliveries, :count)
    end

    it "does NOT send the email when the task is completed" do
      task = create(:task, project:, due_date: Time.zone.today, assignee:,
        completed: true, team:)

      expect do
        described_class.task_due_today(task).deliver_now
      end.not_to change(ActionMailer::Base.deliveries, :count)
    end
  end

  describe "invoice_payment_receipt" do
    let(:designer) { create(:user, :designer) }
    let(:client) { create(:user, :client) }
    let(:project) { create(:project, designers: [designer], created_by: designer) }
    let(:invoice) do
      invoice = create(:invoice, project:, client:, issue_date: Date.parse("2023-05-21"))
      # The invoice_id is generated by a callback so we have to update it manually
      invoice.update_column(:invoice_id, "Invoice 123ABC")
      create(:invoice_item, invoice:, kind: "line", unit_price: 133, qty: 1, name: "Item 123ABC Line 1")
      create(:invoice_item, invoice:, kind: "line", unit_price: 222, qty: 1, name: "Item 123ABC Line 2")
      invoice
    end

    let(:invoice_payment) { create(:invoice_payment, invoice:, date: Date.parse("2023-05-21"), amount: 70) }

    it "sends an email containing the invoice details" do
      mail = described_class.invoice_payment_receipt(invoice, invoice_payment).deliver_now

      expect(mail.body.encoded).to include("Invoice 123ABC")
      expect(mail.body.encoded).to include("TOTAL: $355.00")
      expect(mail.body.encoded).to include("05/21/2023")
    end

    it "sends an email containing the invoice item details" do
      mail = described_class.invoice_payment_receipt(invoice, invoice_payment).deliver_now

      expect(mail.body.encoded).to include("Item 123ABC Line 1")
      expect(mail.body.encoded).to include("$133.00")
      expect(mail.body.encoded).to include("Item 123ABC Line 2")
      expect(mail.body.encoded).to include("$222.00")
    end

    context "custom message" do
      it "sends an email containing the specified custom message" do
        invoice_payment.update_column :custom_message, "This is a custom message!"
        mail = described_class.invoice_payment_receipt(invoice, invoice_payment).deliver_now

        expect(mail.body.encoded).not_to include("Thank you for your purchase!")
        expect(mail.body.encoded).to include("This is a custom message!")
      end

      it "sends an email containing the default custom message if none is provided" do
        mail = described_class.invoice_payment_receipt(invoice, invoice_payment).deliver_now

        expect(mail.body.encoded).to include("Thank you for your purchase!")
        expect(mail.body.encoded).to include(
          "Below you'll find a copy of your receipt and purchase details, please keep them for your records."
        )
      end
    end
  end

  describe "#assigned_subtask" do
    let(:assignee) { create(:user) }
    let(:project) { create(:project) }
    let(:team) { project.team }
    let(:task) { create(:task, project:, team:) }
    let(:subtask) { create(:task, project:, team:, assignee:, parent: task) }
    let(:mail) { described_class.assigned_subtask(subtask) }

    it "have correct headers", :aggregate_failures do
      expect(mail.subject).to eq("Sub-Task Assigned")
      expect(mail.to).to eq([subtask.assignee.email])
    end

    it "have correct link", :aggregate_failures do
      expect(mail.body.encoded).to include("task_id=#{task.id}")
      expect(mail.body.encoded).to include("subtask_id=#{subtask.id}")
    end
  end

  describe "#quote_approved" do
    subject(:mail) do
      described_class.quote_approved(quote, client, designer)
    end

    let(:designer) { create(:user, :member) }
    let(:client) { create(:user, :client) }
    let(:quote) { create(:quote, client:) }

    it "sends the Quote Approved email to the given designer", :aggregate_failures do
      expect(mail.subject).to eq "Quote Approved"
      expect(mail.to).to contain_exactly(designer.email)
    end
  end

  describe "#project_attachment_by_client" do
    subject(:mail) do
      described_class.project_attachment_by_client(user_file, designer)
    end

    let(:project) { create(:project) }
    let(:designer) { create(:user, :member) }
    let(:user_file) { create(:user_file, project:) }

    it "sends the project attachment email to the given designer", :aggregate_failures do
      expect(mail.subject).to match(/has added an attachment for your review/)
      expect(mail.to).to contain_exactly(designer.email)
    end
  end

  describe "#contract_signed" do
    subject(:mail) do
      described_class.contract_signed(contract, designer)
    end

    let(:client) { create(:user, :client) }
    let(:designer) { create(:user, :member) }
    let(:contract) { create(:contract, client:) }

    it "sends the contract signed email to the given designer", :aggregate_failures do
      expect(mail.subject).to eq "Contract Signed"
      expect(mail.to).to contain_exactly(designer.email)
    end
  end

  describe "#invoice_confirmation" do
    subject(:mail) do
      described_class.invoice_confirmation(invoice, payment, false, designer)
    end

    let(:designer) { create(:user, :member) }
    let(:client) { create(:user, :client) }
    let(:invoice) { create(:invoice, client:) }
    let(:payment) { create(:invoice_payment) }

    it "sends the invoice confirmation email to the given designer", :aggregate_failures do
      expect(mail.subject).to eq "Invoice payment confirmation"
      expect(mail.to).to contain_exactly(designer.email)
    end
  end

  describe "#retainer_confirmation" do
    subject(:mail) do
      described_class.retainer_confirmation(retainer, payment, designer)
    end

    let(:designer) { create(:user, :member) }
    let(:client) { create(:user, :client) }
    let(:retainer) { create(:retainer, client:) }
    let(:payment) { create(:invoice_payment) }

    it "sends the invoice confirmation email to the given designer", :aggregate_failures do
      expect(mail.subject).to eq "Retainer payment confirmation"
      expect(mail.to).to contain_exactly(designer.email)
    end
  end

  describe "#ach_payment_succeeded" do
    let(:designer) { create(:user, :designer) }
    let(:client) { create(:user, :client) }
    let(:project) { create(:project, designers: [designer]) }

    subject(:mail) do
      described_class.ach_payment_succeeded(billable, payment)
    end

    context "when billable is an invoice" do
      let(:billable) { create(:invoice, project:, client:) }
      let(:payment) { create(:invoice_payment, invoice: billable) }

      it "sends the payment confirmation email to the designer", :aggregate_failures do
        expect(mail.subject).to eq "Invoice payment confirmation"
        expect(mail.from).to contain_exactly("info@designfiles.co")
        expect(mail.to).to contain_exactly(designer.email)
      end
    end

    context "when billable is a retainer" do
      let(:billable) { create(:retainer, project:, client:) }
      let(:payment) { create(:retainer_payment) }

      it "sends the payment confirmation email to the designer", :aggregate_failures do
        expect(mail.subject).to eq "Retainer payment confirmation"
        expect(mail.from).to contain_exactly("info@designfiles.co")
        expect(mail.to).to contain_exactly(designer.email)
      end
    end
  end

  describe "#ach_payment_failed" do
    let(:designer) { create(:user, :designer) }
    let(:client) { create(:user, :client) }
    let(:project) { create(:project, designers: [designer]) }

    subject(:mail) do
      described_class.ach_payment_failed(billable, payment)
    end

    context "when billable is an invoice" do
      let(:billable) { create(:invoice, project:, client:) }
      let(:payment) { create(:invoice_payment, invoice: billable) }

      it "sends the failed payment email to the designer", :aggregate_failures do
        expect(mail.subject).to eq "Invoice payment failed"
        expect(mail.from).to contain_exactly("info@designfiles.co")
        expect(mail.to).to contain_exactly(designer.email)
      end
    end

    context "when billable is a retainer" do
      let(:billable) { create(:retainer, project:, client:) }
      let(:payment) { create(:retainer_payment) }

      it "sends the failed payment email to the designer", :aggregate_failures do
        expect(mail.subject).to eq "Retainer payment failed"
        expect(mail.from).to contain_exactly("info@designfiles.co")
        expect(mail.to).to contain_exactly(designer.email)
      end
    end
  end
end
